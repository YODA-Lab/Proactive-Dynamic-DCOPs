package agent;

import static java.lang.System.out;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.io.Serializable;
import java.lang.management.ManagementFactory;
import java.lang.management.ThreadMXBean;
import java.util.List;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

import behavior.AGENT_TERMINATE;
import behavior.BROADCAST_RECEIVE_HEURISTIC_INFO;
import behavior.DPOP_UTIL;
import behavior.DPOP_VALUE;
import behavior.INIT_PROPAGATE_DPOP_VALUE;
import behavior.INIT_RECEIVE_DPOP_VALUE;
import behavior.INIT_RECEIVE_SEND_LS_UTIL;
import behavior.LS_RECEIVE_SEND_LS_UTIL;
import behavior.MESSAGE_TYPE;
import behavior.PSEUDOTREE_GENERATION;
import behavior.RAND_PICK_VALUE;
import behavior.RECEIVE_IMPROVE;
import behavior.RECEIVE_VALUE;
import behavior.SEARCH_NEIGHBORS;
import behavior.SEND_IMPROVE;
import table.Row;
import table.Table;
import transition.TransitionFunction;
import jade.core.AID;
import jade.core.Agent;
import jade.core.behaviours.ParallelBehaviour;
import jade.core.behaviours.SequentialBehaviour;
import jade.domain.DFService;
import jade.domain.FIPAException;
import jade.domain.FIPAAgentManagement.DFAgentDescription;
import jade.domain.FIPAAgentManagement.ServiceDescription;
import jade.lang.acl.ACLMessage;
/* Each agent is a node in the graph
 * The graph is presented as pseudo-tree
 * Pseudo-tree is generated by Distributed DFS
 * 
 * Each Agent has a "root" flag to indicate root or not
 * Each Agent has a local name which is an ID number and is assigned by constructor.
 * Based on the ID number, each agent has a fixed number neighbors, which is instantiated
 * by the constructor
 * 
 * ****PROCESS OF FINDING AID NEIGHBORS
 * Each Agent has a list of neighbors, and register his neighbors ID number to DF
 * Each Agent find his neighbors' AIDs by searching DF which agents register the Agent's ID numbers as
 * a neighbor. The add to his list of AID neighbors.
 * 
 * The process of finding AIDs only stops when the number of recognized AID is the number of his neighbors
 * 
 * ****PROCESS OF GENERATING PSEUDOTREE
 * Each agent always listens to the first messages, while trying to finish the searching process
 * After finishing the searching process, he begins to process the messages and send the message to his
 * neighbors.
 * 
 * Agent root start sending messages when finish searching agents.
 * 
 * Each agents will print out his parent, his children, his pseudo-parents, his pseudo-children
 * 
 * ****PROCESS OF DPOP
 * DPOP starts when the PSEUDOTREE PROCESS FINISHED
 */
/**
 * @author khoihd
 *
 */
public class AgentPDDCOP extends Agent {

	private static final long serialVersionUID = 2919994686894853596L;
	
  public static enum DcopAlgorithm {
    C_DPOP, 
    LS_SDPOP, 
    LS_RAND, 
    FORWARD, 
    BACKWARD, 
    MULTI_CDPOP, 
    SDPOP, 
    REACT, 
    HYBRID,
    JESP
  }
  
  public static enum SwitchingType {
    CONSTANT,
    LINEAR,
    QUADRATIC,
    EXP_2,
    EXP_3
  }
  
  public static enum DynamicType {
    FINITE_HORIZON,
    INFINITE_HORIZON,
    HYBRID,
    REACT
  }

  public static final SwitchingType SWITCHING_TYPE = SwitchingType.CONSTANT;
  public static final int MAX_ITERATION = 30;
  public static final int MARKOV_CONVERGENCE_TIME_STEP = 40;

  /*
   * DCOP parameters
   * To be read from arguments
   */
  private String agentID;
	private DcopAlgorithm algorithm;
	private int horizon;
	private double switchingCost;
	private DynamicType dynamicType;
  private double discountFactor;
  private String inputFileName;

	/*
	 * To be read from input file
	 */
	private int instanceID;
	/*
	 * To be computed from the arguments
	 */
	private String outputFileName;

	private int hybridTS;
	
	private boolean isRoot = false;
	private boolean isLeaf = false;

	private AID parentAID;
	private List<AID> childrenAIDList = new ArrayList<>();
	private List<AID> neighborAIDList = new ArrayList<>();
	private List<AID> pseudoParentAIDList = new ArrayList<>();
	private List<AID> pseudoChildrenAIDList = new ArrayList<>();
	private List<String> parentAndPseudoStrList = new ArrayList<>();
	private List<String> neighborStrList = new ArrayList<>();
	
	private List<Table> dpopDecisionTableList = new ArrayList<>();
	private List<Table> dpopRandomTableList = new ArrayList<>();

	private List<Table> rawDecisionTableList = new ArrayList<>();
	private List<Table> rawRandomTableList = new ArrayList<>();

	private List<String> decisionVariableList = new ArrayList<>();
	private List<String> randomVariableList = new ArrayList<>();
	private HashMap<String, List<String>> decisionVariableDomainMap = new HashMap<>();
	private HashMap<String, List<String>> randomVariableDomainMap = new HashMap<>();
	// map TS -> constraint table list (if local_search)
	// map TS -> 1 collapsed table list (if collapsed dpop)
	private HashMap<Integer, List<Table>> constraintTableAtEachTSMap = new HashMap<>();
	private HashMap<String, double[][]> probabilityAtEachTimeStepMap = new HashMap<>();

	// VALUE phase
	Map<String, String> valuesToSendInVALUEPhase = new HashMap<>();

	// used for LOCAL SEARCH
	private Map<Integer, String> chosenValueAtEachTSMap = new HashMap<>();
	// List<Double> utilityAtEachTSList;
	// agent -> <values0, values1, ..., values_n>
	private Map<String, HashMap<Integer, String>> agentViewEachTimeStepMap = new HashMap<>();
	private List<Double> currentGlobalUtilityList = new ArrayList<>();
	private List<String> bestImproveValueList = new ArrayList<>();
	private List<Double> bestUtilityList = new ArrayList<>();
  private List<Double> bestImproveUtilityList;

	/**
	 * Object since it could be null
	 */
	private double currentLocalSearchSolutionQuality;
	private double solutionQuality;

	private Map<String, List<Double>> initProabilityMap = new HashMap<>();
	/**
	 * Random variable -> TransitionFunction
	 */
	private Map<String, TransitionFunction> transitionFunctionMap = new HashMap<>();
	private Table agentViewTable;
	private Map<Integer, String> pickedRandomMap = new HashMap<>();
	
	private long currentUTILstartTime;
	private int localSearchIteration;

	// simulated time
	private ThreadMXBean bean;
	private long simulatedTime = 0;
	private long currentStartTime;
	private static long delayMessageTime = 0; // in milliseconds

	// for reuse information
	private Map<AID, Integer> constraintInfoMap;
	private boolean notVisited = true;

	// List<String> neighborWithRandList;

	// Store the quality of the best LS solution
	private double bestLocalSearchQuality;
	
	private boolean stop = false;
	private double curentLocalSearchQuality;
	private String lastLine = "";
  private int agentCount;

	public AgentPDDCOP() {
	}

	// done with LS-RAND
	public void readArguments() {
		Object[] args = getArguments();
    out.println(Arrays.deepToString(args));
    
		// parameters for running experiments
		algorithm = DcopAlgorithm.valueOf((String) args[0]);
		inputFileName = (String) args[1]; // rep_10_d14.dzn
		horizon = Integer.valueOf((String) args[2]);
		switchingCost = Integer.valueOf((String) args[3]);
		discountFactor = Double.valueOf((String) args[4]);
		dynamicType = DynamicType.valueOf((String) args[5]);
		
		String a[] = inputFileName.replaceAll("rep_", "").replaceAll(".dzn", "").split("_d");
		
		instanceID = Integer.valueOf(a[0]);
		
		agentCount = Integer.valueOf(a[1]);
		
		agentID = getLocalName();

		for (int timeStep = 0; timeStep <= horizon; timeStep++) {
			constraintTableAtEachTSMap.put(timeStep, new ArrayList<Table>());
		}
		
		outputFileName = algorithm + "_d=" + agentCount + "_sw=" + (int) switchingCost + "_h=" + horizon + ".txt";
	}

	protected void setup() {
		readArguments();
		// Set root
		isRoot = agentID.equals("1") ? true : false;
		
		if (isRoot) {
			System.out.println("Algorithm =  " + algorithm);
			System.out.println("Input file name = " + inputFileName);
	    System.out.println("InstanceID = " + instanceID);
			System.out.println("Horizon = " + horizon);
			System.out.println("Max iteration = " + MAX_ITERATION);		
		}

		parseInputFile(inputFileName);
    registerWithDF();   
    bean = ManagementFactory.getThreadMXBean();
    bean.setThreadContentionMonitoringEnabled(true);
    
    int randomDomainSize = randomVariableDomainMap.get(agentID).size();
    probabilityAtEachTimeStepMap.put(getAgentID(), new double[horizon + 1][randomDomainSize]);
    
    int theLastTimeStep = horizon;
    if (dynamicType == DynamicType.INFINITE_HORIZON) {
      createStableProbabilityForLastTimeStep();
      theLastTimeStep = horizon - 1;
      for (int timeIndex = 0; timeIndex <= theLastTimeStep; timeIndex++) {
        computeExpectedProbabilityAtTimeStep(timeIndex);
      }
    }
    else if (dynamicType == DynamicType.FINITE_HORIZON) {
      for (int timeIndex = 0; timeIndex <= theLastTimeStep; timeIndex++) {
        computeExpectedProbabilityAtTimeStep(timeIndex);
      }
    }
    else if (dynamicType == DynamicType.HYBRID) {
      for (int indexTime = 0; indexTime <= theLastTimeStep; indexTime++) {
        addPickedRandomMap(indexTime, simulateRandom(indexTime));
        createProbabilityWithObservation(indexTime);
      }
    }
    else if (dynamicType == DynamicType.REACT) {
      // Do nothing
    }
    
    dpopDecisionTableList.addAll(getTableWithoutChildrenAndPseudochilren(rawDecisionTableList));
    dpopRandomTableList.addAll(getTableWithoutChildrenAndPseudochilren(rawRandomTableList));

		SequentialBehaviour mainSequentialBehaviourList = new SequentialBehaviour();
		mainSequentialBehaviourList.addSubBehaviour(new SEARCH_NEIGHBORS(this));
		mainSequentialBehaviourList.addSubBehaviour(new BROADCAST_RECEIVE_HEURISTIC_INFO(this));
		mainSequentialBehaviourList.addSubBehaviour(new PSEUDOTREE_GENERATION(this));
		
		if (dynamicType == DynamicType.INFINITE_HORIZON) {
      mainSequentialBehaviourList.addSubBehaviour(new DPOP_UTIL(this, horizon));
      mainSequentialBehaviourList.addSubBehaviour(new DPOP_UTIL(this, horizon));
    }
    
    if (algorithm == DcopAlgorithm.C_DPOP) {
      mainSequentialBehaviourList.addSubBehaviour(new DPOP_UTIL(this, theLastTimeStep));
      mainSequentialBehaviourList.addSubBehaviour(new DPOP_UTIL(this, theLastTimeStep));
    }
    else if (isAlgorithmIn(new DcopAlgorithm[]{
    DcopAlgorithm.LS_SDPOP, DcopAlgorithm.FORWARD, DcopAlgorithm.BACKWARD})) {
      for (int i = 0; i <= theLastTimeStep; i++) {
        mainSequentialBehaviourList.addSubBehaviour(new DPOP_UTIL(this, i));
        mainSequentialBehaviourList.addSubBehaviour(new DPOP_VALUE(this, i));
      }
    }
    else if (algorithm == DcopAlgorithm.LS_RAND) {
      mainSequentialBehaviourList.addSubBehaviour(new RAND_PICK_VALUE(this));
    }     
     		
		if (isAlgorithmIn(new DcopAlgorithm[]{DcopAlgorithm.LS_RAND, DcopAlgorithm.LS_SDPOP})) {
		  
		  for (int timeIndex  = 0; timeIndex <= theLastTimeStep; timeIndex++) {
		    constraintTableAtEachTSMap.get(timeIndex).addAll(computeDiscountedDecisionTableList(rawDecisionTableList, timeIndex, discountFactor));
        constraintTableAtEachTSMap.get(timeIndex).addAll(computeDiscountedDecisionTableList(rawRandomTableList, timeIndex, discountFactor));
		  }
		  
		  mainSequentialBehaviourList.addSubBehaviour(new INIT_PROPAGATE_DPOP_VALUE(this));
			mainSequentialBehaviourList.addSubBehaviour(new INIT_RECEIVE_DPOP_VALUE(this));
			mainSequentialBehaviourList.addSubBehaviour(new INIT_RECEIVE_SEND_LS_UTIL(this, theLastTimeStep));
			
			mainSequentialBehaviourList.addSubBehaviour(new SEND_IMPROVE(this, theLastTimeStep));
      ParallelBehaviour localSearch = new ParallelBehaviour();
      localSearch.addSubBehaviour(new RECEIVE_IMPROVE(this, theLastTimeStep));
      localSearch.addSubBehaviour(new RECEIVE_VALUE(this));
      localSearch.addSubBehaviour(new LS_RECEIVE_SEND_LS_UTIL(this, theLastTimeStep));
      mainSequentialBehaviourList.addSubBehaviour(localSearch);
		}

		mainSequentialBehaviourList.addSubBehaviour(new AGENT_TERMINATE(this));
		addBehaviour(mainSequentialBehaviourList);
	}

  // JADE function: stop the Agent
	protected void takeDown() {
		System.out.println("Agent " + agentID + " with threadID " + Thread.currentThread().getId()
				+ " has SIMULATED TIME: " + simulatedTime / 1000000 + "ms");
		System.err.println("Agent " + getAID().getName() + " is terminated.");
		try {
			DFService.deregister(this);
		} catch (FIPAException e) {
			e.printStackTrace();
		}
	}
	
  public void sendImprove(int lastTimeStep) {
    
    startSimulatedTiming();
    
//    currentStartTime = bean.getCurrentThreadUserTime();

    List<Double> currentUtilityList = utilityMinusCostOverTS(chosenValueAtEachTSMap, lastTimeStep);

    double maxUtility = Integer.MIN_VALUE;

    List<String> domain = getSelfDomain();
    int domainSize = domain.size();
    int totalSize = (int) Math.pow(domainSize, lastTimeStep + 1);

    for (int index = 0; index < totalSize; index++) {
      // a list of values at every time step
      ArrayList<String> valueListTS = new ArrayList<String>();
      int temp = index;
      for (int k = 0; k <= lastTimeStep; k++) {
        valueListTS.add(domain.get(temp % domainSize));
        temp = temp / domainSize;
      }
      // Collections.reverse(valueListTS);

      double evaluation = utilityMinusSwitchingCost(valueListTS);
      if (evaluation > maxUtility) {
        maxUtility = evaluation;
        bestImproveValueList = valueListTS;
      }
    }

    bestImproveUtilityList = new ArrayList<Double>();
    if (maxUtility != Integer.MIN_VALUE) {
      bestUtilityList = utilityMinusCostOverTSList(bestImproveValueList);
      for (int i = 0; i <= lastTimeStep; i++) {
        bestImproveUtilityList.add(bestUtilityList.get(i) - currentUtilityList.get(i));
      }
    }

//    simulatedTime += bean.getCurrentThreadUserTime() - currentStartTime;
    stopStimulatedTiming();

    for (AID neighbor : neighborAIDList) {
      sendObjectMessageWithTime(neighbor, bestImproveUtilityList, MESSAGE_TYPE.LS_IMPROVE, simulatedTime);
    }
  }

	public void archivedSendImprove(int lastTimeStep) {
		currentStartTime = bean.getCurrentThreadUserTime();
    
		Double bestImproveUtility = null;

		List<Double> currentUtilityList = utilityMinusCostOverTS(chosenValueAtEachTSMap, lastTimeStep);

		double maxUtility = -Double.MAX_VALUE;

		List<String> domain = decisionVariableDomainMap.get(agentID);
		
		int domainSize = domain.size();
		int totalSize = (int) Math.pow(domainSize, lastTimeStep + 1);

		for (int index = 0; index < totalSize; index++) {
			// a list of values at every time step
			List<String> valueListTS = new ArrayList<String>();
			int temp = index;
			
			for (int k = 0; k <= lastTimeStep; k++) {
				valueListTS.add(domain.get(temp % domainSize));
				temp = temp / domainSize;
			}
			// Collections.reverse(valueListTS);

			double evaluation = utilityMinusSwitchingCost(valueListTS);
			if (evaluation > maxUtility) {
				maxUtility = evaluation;
				bestImproveValueList = valueListTS;
			}
		}
		
		if (maxUtility != Integer.MIN_VALUE) {
			Map<Integer, String> valueMap = new HashMap<>();
			for (int i = 0; i < bestImproveValueList.size(); i++) {
			  valueMap.put(i, bestImproveValueList.get(i));
			}
		  
	    bestUtilityList = utilityMinusCostOverTS(valueMap, lastTimeStep);

	    bestImproveUtility = 0D;
	    for (int i = 0; i <= lastTimeStep; i++) {
				bestImproveUtility += bestUtilityList.get(i) - currentUtilityList.get(i);
			}
			bestImproveUtility = new Double(maxUtility);
		}

		simulatedTime += bean.getCurrentThreadUserTime() - currentStartTime;

		// send IMPROVE messages
		for (AID neighbor : neighborAIDList) {
			sendObjectMessageWithTime(neighbor, bestImproveUtility, MESSAGE_TYPE.LS_IMPROVE, simulatedTime);
		}
	}
	
  /**
   * Remove children and pseudoChildren constraint table
   */
  public List<Table> getTableWithoutChildrenAndPseudochilren(List<Table> tableList) {
    List<String> childAndPseudoChildrenStrList = new ArrayList<String>();
    for (AID childrenAID : childrenAIDList) {
      childAndPseudoChildrenStrList.add(childrenAID.getLocalName());
    }
    for (AID pseudoChildrenAID : pseudoChildrenAIDList) {
      childAndPseudoChildrenStrList.add(pseudoChildrenAID.getLocalName());
    }
    
    List<Table> resultingTableList = new ArrayList<>(tableList);

    for (Table constraintTable : tableList) {
      List<String> decLabelList = constraintTable.getDecVarLabel();
      for (String children : childAndPseudoChildrenStrList) {
        if (decLabelList.contains(children)) {
          resultingTableList.remove(constraintTable);
          break;
        }
      }
    }

    return resultingTableList;    
  }

	double utilityMinusSwitchingCost(List<String> valuesOverTS) {
		double sumUtility = 0;
		double sumCost = 0;
		for (int ts = 0; ts <= horizon; ts++) {
			List<Table> tableList = constraintTableAtEachTSMap.get(ts);
			for (Table constraintTable : tableList) {
				List<String> decVarList = constraintTable.getDecVarLabel();
				List<String> decValueList = new ArrayList<String>();
				// get value from agentView
				// add value to decValue -> getUtility
				for (String neighbor : decVarList) {
					if (neighbor.equals(agentID))
						decValueList.add(valuesOverTS.get(ts));
					else
						decValueList.add(agentViewEachTimeStepMap.get(neighbor).get(ts));
				}
				sumUtility += constraintTable.getUtilityGivenDecValueList(decValueList);
			}
		}

		for (int i = 1; i < valuesOverTS.size(); i++) {
			// sumCost += valuesOverTS.get(i).equals(valuesOverTS.get(i-1)) ? 0
			// : switchingCost * Math.pow(discountFactor, i-1);
			// sumCost += valuesOverTS.get(i).equals(valuesOverTS.get(i-1)) ? 0
			// : switchingCost;
			sumCost += switchingCostFunction(valuesOverTS.get(i), valuesOverTS.get(i - 1));
		}
		return sumUtility + sumCost;
	}

	private List<Double> utilityMinusCostOverTS(Map<Integer, String> timeStepValueMap, int timeStep) {
		List<Double> utilityList = new ArrayList<Double>();
		for (int ts = 0; ts <= timeStep; ts++) {
			double sc = 0;
			double utility = 0;
			if (ts == 0) {
				sc = switchingCostFunction(timeStepValueMap.get(0), timeStepValueMap.get(1));
			}
			else if (ts == horizon) {
				sc = switchingCostFunction(timeStepValueMap.get(horizon), timeStepValueMap.get(horizon - 1));
			}
			else {
				sc = switchingCostFunction(timeStepValueMap.get(ts - 1), timeStepValueMap.get(ts))
						+ switchingCostFunction(timeStepValueMap.get(ts), timeStepValueMap.get(ts + 1));
			}
			// from each utility constraint with neighbors at a timeStep
			// get names -> get values from agent_view
			// from neighbors' values, current value -> get utility from
			// constraint table
			List<Table> tableList = constraintTableAtEachTSMap.get(ts);
			// System.err.println("Agent " + idStr + " size " +
			// tableList.size());
			for (Table constraintTable : tableList) {
				List<String> decVarList = constraintTable.getDecVarLabel();
				List<String> decValueList = new ArrayList<String>();
				// get value from agentView
				// add value to decValue -> getUtility
				for (String neighbor : decVarList) {
					if (neighbor.equals(agentID))
						decValueList.add(timeStepValueMap.get(ts));
					else
						decValueList.add(agentViewEachTimeStepMap.get(neighbor).get(ts));
				}
				utility += constraintTable.getUtilityGivenDecValueList(decValueList);
			}

			utilityList.add(utility - sc);
		}
		return utilityList;
	}

	// utilityMinusCostOverTSList
	List<Double> utilityMinusCostOverTSList(List<String> valuesOverTS) {
		List<Double> utilityList = new ArrayList<Double>();
		for (int ts = 0; ts <= horizon; ts++) {
			double sc = 0;
			double utility = 0;
			if (ts == 0)
				// sc = (valuesOverTS.get(0).equals(valuesOverTS.get(1))
				// ? 0 : switchingCost);
				sc = switchingCostFunction(valuesOverTS.get(0), valuesOverTS.get(1));
			else if (ts == horizon)
				// sc = (valuesOverTS.get(h).equals(valuesOverTS.get(h-1))
				// ? 0 : switchingCost);
				sc = switchingCostFunction(valuesOverTS.get(horizon), valuesOverTS.get(horizon - 1));
			else
				// sc = (valuesOverTS.get(ts-1).equals(valuesOverTS.get(ts))
				// ? 0 : switchingCost)
				// + (valuesOverTS.get(ts).equals(valuesOverTS.get(ts+1))
				// ? 0 : switchingCost);
				sc = switchingCostFunction(valuesOverTS.get(ts - 1), valuesOverTS.get(ts))
						+ switchingCostFunction(valuesOverTS.get(ts), valuesOverTS.get(ts + 1));

			// from each utility constraint with neighbors at a timeStep
			// get names -> get values from agent_view
			// from neighbors' values, current value -> get utility from
			// constraint table
			List<Table> tableList = constraintTableAtEachTSMap.get(ts);
			// System.err.println("Agent " + idStr + " size " +
			// tableList.size());
			for (Table constraintTable : tableList) {
				List<String> decVarList = constraintTable.getDecVarLabel();
				List<String> decValueList = new ArrayList<String>();
				// get value from agentView
				// add value to decValue -> getUtility
				for (String neighbor : decVarList) {
					if (neighbor.equals(agentID))
						decValueList.add(valuesOverTS.get(ts));
					else
						decValueList.add(agentViewEachTimeStepMap.get(neighbor).get(ts));
				}
				utility += constraintTable.getUtilityGivenDecValueList(decValueList);
			}

			utilityList.add(utility - sc);
		}
		return utilityList;
	}

	public void createProbabilityWithObservation(int timeStep) {
		if (timeStep == 0) {
			computeExpectedProbabilityAtTimeStep(0);
			return;
		}
		for (String randVariable : randomVariableList) {
			double distribution[] = toArray(
					transitionFunctionMap.get(randVariable).getTransitionOf(pickedRandomMap.get(timeStep - 1)));
			probabilityAtEachTimeStepMap.get(randVariable)[timeStep] = distribution;
		}
	}

	public void computeExpectedProbabilityAtTimeStep(int timeStep) {
		for (String randVariable : randomVariableList) {
			if (timeStep == 0) {
				List<Double> initProbList = initProabilityMap.get(randVariable);
				for (int i = 0; i < randomVariableDomainMap.get(randVariable).size(); i++) {
					probabilityAtEachTimeStepMap.get(randVariable)[0][i] = initProbList.get(i);
				}
			}
			else {
				double[] prevDistribution = probabilityAtEachTimeStepMap.get(randVariable)[timeStep - 1];
				double[] currDistribution = multiply(prevDistribution, transitionFunctionMap.get(randVariable));
				probabilityAtEachTimeStepMap.get(randVariable)[timeStep] = currDistribution;
			}
		}
	}

	public void createStableProbabilityForLastTimeStep() {
		// for each random variables
		for (String randVariable : randomVariableList) {
			double distribution[] = probabilityAtEachTimeStepMap.get(randVariable)[0];
			// multiply to get stable distribution
			for (int i = 0; i <= AgentPDDCOP.MARKOV_CONVERGENCE_TIME_STEP; i++) {
				distribution = multiply(distribution, transitionFunctionMap.get(randVariable));
			}
			probabilityAtEachTimeStepMap.get(randVariable)[horizon] = distribution;
		}
	}

	// for each agent, create probability for valueList at each timeStep of each
	// randomVariable
	// add to probabilityAtEachTimeStepMap
	public void createAndAddProbabilityAtEachTimeStep() {
		// get each random Variable from randomVariableList
		// add to probabilityAtEachTimeStepMap
		// int columnNo = timeStepAllowed + 1;
		int columnNo = horizon + 1;
		for (int randVarIndex = 0; randVarIndex < randomVariableList.size(); randVarIndex++) {
			String randVariable = randomVariableList.get(randVarIndex);
			int domainSize = randomVariableDomainMap.get(randVariable).size();
			// each row is a timeStep from 0 to finalTimeStep
			// each column is a value from domain
			double[][] probAtEachTS = new double[columnNo][domainSize];
			TransitionFunction transMatrix = transitionFunctionMap.get(randVariable);
			for (int row = 0; row < columnNo; row++) {
				if (row == 0) {
					List<Double> initProbList = initProabilityMap.get(randVariable);
					for (int col = 0; col < domainSize; col++) {
						probAtEachTS[row][col] = initProbList.get(col);
					}
					continue;
				}
				for (int col = 0; col < domainSize; col++) {
					double probabilityAtATime = 0;
					for (int upperCol = 0; upperCol < domainSize; upperCol++) {
						probabilityAtATime += probAtEachTS[row - 1][upperCol]
								* transMatrix.getProbByIndex(upperCol, col);
					}
					probAtEachTS[row][col] = probabilityAtATime;
				}
			}
			probabilityAtEachTimeStepMap.put(randVariable, probAtEachTS);
		}
	}

	public List<List<String>> getAllTupleValueOfGivenLabel(List<String> varLabel, boolean isDecVar) {
		List<List<String>> allTuple = new ArrayList<List<String>>();
		List<Integer> sizeDomainList = new ArrayList<Integer>();
		int totalSize = 1;
		for (String randVar : varLabel) {
			int domainSize = 0;

			if (isDecVar) {
				domainSize = decisionVariableDomainMap.get(randVar).size();
			} else
				domainSize = randomVariableDomainMap.get(randVar).size();
			sizeDomainList.add(domainSize);
			totalSize *= domainSize;
		}

		int noVar = varLabel.size();

		// go from 0 to totalSize
		for (int count = 0; count < totalSize; count++) {
			List<String> valueTuple = new ArrayList<String>();
			int quotient = count;
			// for each value count, decide the index of each column, then add
			// to the tuple
			for (int varIndex = noVar - 1; varIndex >= 0; varIndex--) {
				int remainder = quotient % sizeDomainList.get(varIndex);
				quotient = quotient / sizeDomainList.get(varIndex);
				if (isDecVar)
					valueTuple.add(decisionVariableDomainMap.get(varLabel.get(varIndex)).get(remainder));
				else
					valueTuple.add(randomVariableDomainMap.get(varLabel.get(varIndex)).get(remainder));
			}
			Collections.reverse(valueTuple);
			allTuple.add(valueTuple);
		}

		return allTuple;
	}

//	public double getUtilityFromTableGivenDecAndRand(Table table, List<String> decValueList,
//			List<String> randIterationValue) {
//		List<Row> tableToTraversed = table.getRowList();
//		for (Row row : tableToTraversed) {
//			boolean isRowFound = true;
//			// System.err.println("Utility of this row " + row.getUtility());
//			List<String> rowValueList = row.getValueList();
//			List<String> rowRandomList = row.getRandomList();
//
//			if (rowValueList.size() != decValueList.size() || rowRandomList.size() != randIterationValue.size()) {
//				System.err.println("!!!!!!Different size!!!!!!!!!");
//				System.err.println("!!!!!!Recheck your code!!!!!!");
//			}
//			for (int index = 0; index < decValueList.size(); index++) {
//				if (rowValueList.get(index).equals(decValueList.get(index)) == false) {
//					isRowFound = false;
//					break;
//				}
//			}
//
//			if (isRowFound == false)
//				continue;
//
//			for (int index = 0; index < randIterationValue.size(); index++) {
//				if (rowRandomList.get(index).equals(randIterationValue.get(index)) == false) {
//					isRowFound = false;
//					break;
//				}
//			}
//
//			if (isRowFound == false)
//				continue;
//
//			return row.getUtility();
//		}
//		System.out.println("Not found!!!!!!!!!!!!!!");
//		return Integer.MIN_VALUE;
//	}

	public void sendObjectMessage(AID receiver, Object content, int msgCode) {
		ACLMessage message = new ACLMessage(msgCode);
		try {
			message.setContentObject((Serializable) content);
		} catch (IOException e) {
			e.printStackTrace();
		}
		message.addReceiver(receiver);
		send(message);
	}

	public void sendObjectMessageWithTime(AID receiver, Object content, int msgCode, long time) {
		ACLMessage message = new ACLMessage(msgCode);
		try {
			message.setContentObject((Serializable) content);
		} catch (IOException e) {
			e.printStackTrace();
		}
		message.addReceiver(receiver);
		message.setLanguage(String.valueOf(time));
		send(message);
	}

	public void printTree() {
		System.out.println("************");
		System.out.println("My ID is: " + agentID);
		if (!isRoot)
			System.out.println("My parent is: " + parentAID.getLocalName());
		System.out.println("My children are: ");
		for (int i = 0; i < childrenAIDList.size(); i++) {
			System.out.print(childrenAIDList.get(i).getLocalName() + " ");
		}
		System.out.println();

		System.out.println("My pseudo_parents are: ");
		for (int i = 0; i < pseudoParentAIDList.size(); i++) {
			System.out.print(pseudoParentAIDList.get(i).getLocalName() + " ");
		}
		System.out.println();

		System.out.println("My pseudo_children are: ");
		for (int i = 0; i < pseudoChildrenAIDList.size(); i++) {
			System.out.print(pseudoChildrenAIDList.get(i).getLocalName() + " ");
		}
		System.out.println();

	}

	public void parseInputFile(String inputFileName) {
		final String RANDOM_VARIABLE = "random";
		final String DECISION_VARIABLE = "decision";
		final String REWARD_TABLE_PREFIX = "rewardTable";
		final String TRANS_FUNC_PREFIX = "transition";
		final String INIT_PROB_PREFIX = "initProbability";

		try (BufferedReader br = new BufferedReader(
				new FileReader(System.getProperty("user.dir") + '/' + inputFileName))) {
			List<String> lineWithSemiColonList = new ArrayList<String>();

			String line = br.readLine();
			while (line != null) {
				if (line.length() == 0 || line.startsWith("%") == true) {
					line = br.readLine();
					continue;
				}

				// concatenate line until meet ';'
				if (line.endsWith(";") == false) {
					do {
						line += br.readLine();
					} while (line.endsWith(";") == false);
				}

				line = line.replace(" ", "");
				line = line.replace(";", "");
				lineWithSemiColonList.add(line);
				line = br.readLine();
			}

			// Process line by line;
			for (String lineWithSemiColon : lineWithSemiColonList) {
				// print input file for agent0
				String nameMzn = lineWithSemiColon.split("=")[0];
				String valueMzn = lineWithSemiColon.split("=")[1];

				/** TRANS_FUNC_PREFIX */
				if (nameMzn.contains(TRANS_FUNC_PREFIX)) {
					String randomVariable;
					List<List<Double>> newTransitionMatrix;

					nameMzn = nameMzn.replaceAll(TRANS_FUNC_PREFIX, "");
					randomVariable = nameMzn;

					// Read variables related to agentID only
					if (!randomVariable.equals(agentID)) {
						continue;
					}

					/** create transition function **/
					newTransitionMatrix = new ArrayList<List<Double>>();
					List<String> listOfRow;
					/** process table values **/
					valueMzn = valueMzn.replace("[", "");
					valueMzn = valueMzn.replace("]", "");
					valueMzn = valueMzn.substring(1, valueMzn.length() - 1);
					listOfRow = new ArrayList<String>(Arrays.asList(valueMzn.split("\\|")));
					for (String oneRow : listOfRow) {
						List<String> valueStrList = new ArrayList<String>(Arrays.asList(oneRow.split(",")));
						List<Double> valueDoubleList = new ArrayList<Double>();

						for (String valueStr : valueStrList) {
							valueDoubleList.add(Double.parseDouble(valueStr));
						}
						newTransitionMatrix.add(valueDoubleList);
					}
					TransitionFunction newTransitionFunction = new TransitionFunction(
							randomVariableDomainMap.get(randomVariable), newTransitionMatrix);
					transitionFunctionMap.put(randomVariable, newTransitionFunction);
				}
				/** INIT_PROB_PREFIX */
				if (nameMzn.contains(INIT_PROB_PREFIX)) {
					String randomVariable;
					List<String> initProbabilityStrList;
					List<Double> initProbabilityDoubleList = new ArrayList<Double>();
					nameMzn = nameMzn.replace(INIT_PROB_PREFIX, "");
					randomVariable = nameMzn;

					// Read variable with agentID only
					if (!randomVariable.equals(agentID))
						continue;

					// process values
					valueMzn = valueMzn.replace("[", "");
					valueMzn = valueMzn.replace("]", "");
					initProbabilityStrList = new ArrayList<>(Arrays.asList(valueMzn.split(",")));
					for (String strValue : initProbabilityStrList) {
						initProbabilityDoubleList.add(Double.parseDouble(strValue));
					}
					initProabilityMap.put(randomVariable, initProbabilityDoubleList);
				}
				/** DECISION_VARIABLE */
				// read decision variable domain
				if (nameMzn.contains(DECISION_VARIABLE)) {
					// process name
					String decisionVariable;
					List<String> valueOfDecisionVariableList;
					nameMzn = nameMzn.replace(DECISION_VARIABLE, "");
					decisionVariable = nameMzn;

					// process values
					valueMzn = valueMzn.replace("[", "");
					valueMzn = valueMzn.replace("]", "");
					valueOfDecisionVariableList = new ArrayList<String>(Arrays.asList(valueMzn.split(",")));

					decisionVariableList.add(decisionVariable);
					decisionVariableDomainMap.put(decisionVariable, valueOfDecisionVariableList);
				}
				/** RANDOM_VARIABLE */
				// read random variable domain
				if (nameMzn.contains(RANDOM_VARIABLE)) {
					// process name
					String randomVariable;
					List<String> valueOfRandomVariableList;
					nameMzn = nameMzn.replace(RANDOM_VARIABLE, "");
					randomVariable = nameMzn;

					// Read variable with agentID only
					if (randomVariable.equals(agentID) == false)
						continue;

					// process values
					valueMzn = valueMzn.replace("[", "");
					valueMzn = valueMzn.replace("]", "");
					valueOfRandomVariableList = new ArrayList<String>(Arrays.asList(valueMzn.split(",")));
					randomVariableList.add(randomVariable);
					randomVariableDomainMap.put(randomVariable, valueOfRandomVariableList);
				}
				/** REWARD_TABLE_PREFIX */
				/**
				 * process name of constraint table, create table with the
				 * corresponding name
				 **/
				if (nameMzn.contains(REWARD_TABLE_PREFIX)) {
					Table newRewardTable;
					List<String> variableLabel;
					List<String> listOfRow;
					nameMzn = nameMzn.replaceAll(REWARD_TABLE_PREFIX + "_", "");

					variableLabel = new ArrayList<String>(Arrays.asList(nameMzn.split("_")));
					/**
					 * Variable List does not contain its agent variable So we
					 * skip to process the next line
					 */
					if (variableLabel.contains("d" + agentID) == false)
						continue;
					/**** WITHOUT random variable **********/
					boolean notContainRandom = true;
					for (String var : variableLabel) {
						if (var.startsWith("r")) {
							notContainRandom = false;
							break;
						}
					}
					if (notContainRandom == true) {
						/** add variable to neighborList **/
						List<String> variableLabel_new = new ArrayList<>();
						for (String var : variableLabel) {
							/* add to neighbor list */
							var = var.replace("d", "");
							if (!var.equals(agentID) && !neighborStrList.contains(var))
								neighborStrList.add(var);
							variableLabel_new.add(var);
						}
						/** create Table **/
						newRewardTable = new Table(variableLabel_new);

						/** process table values **/
						valueMzn = valueMzn.replace("[", "");
						valueMzn = valueMzn.replace("]", "");
						valueMzn = valueMzn.substring(1, valueMzn.length() - 1);
						listOfRow = new ArrayList<String>(Arrays.asList(valueMzn.split("\\|")));

						for (String oneRow : listOfRow) {
							List<String> valueList = new ArrayList<String>(Arrays.asList(oneRow.split(",")));
							double utility = Double.parseDouble(valueList.get(valueList.size() - 1));
							valueList.remove(valueList.size() - 1);
							Row newRow = new Row(valueList, utility);
							newRewardTable.addRow(newRow);
						}
//						constraintTableWithoutRandomList.add(newRewardTable);
						rawDecisionTableList.add(newRewardTable);
					}
					/**** WITH random variable **********/
					else {
						/** Process nameMzn */
						int decisionVarCount = 0;
						List<String> decVarLabel = new ArrayList<String>();
						List<String> randVarLabel = new ArrayList<String>();
						for (String var : variableLabel) {
							if (var.startsWith("d")) {
								decisionVarCount++;
								decVarLabel.add(var.replace("d", ""));
							} else if (var.startsWith("r")) {
								randVarLabel.add(var.replace("r", ""));
							}
						}
						/** add variable to neighborList **/
						for (String var : decVarLabel) {
							/* add to neighbor list */
							if (!neighborStrList.contains(var) && !var.equals(agentID)) {
								neighborStrList.add(var);
							}
						}
						/** create Table **/
						// System.out.println("!" + decVarLabel + " " +
						// randVarLabel);
						newRewardTable = new Table(decVarLabel, randVarLabel);

						/** process table values **/
						valueMzn = valueMzn.replace("[", "");
						valueMzn = valueMzn.replace("]", "");
						valueMzn = valueMzn.substring(1, valueMzn.length() - 1);
						listOfRow = new ArrayList<String>(Arrays.asList(valueMzn.split("\\|")));
						for (String oneRow : listOfRow) {
							List<String> decAndRandValueList = new ArrayList<String>(
									Arrays.asList(oneRow.split(",")));
							List<String> decValueList = new ArrayList<String>();
							List<String> randValueList = new ArrayList<String>();
							double utility = Double
									.parseDouble(decAndRandValueList.get(decAndRandValueList.size() - 1));
							decAndRandValueList.remove(decAndRandValueList.size() - 1);
							for (int i = 0; i < decisionVarCount; i++) {
								decValueList.add(decAndRandValueList.get(i));
							}
							for (int i = decisionVarCount; i < decAndRandValueList.size(); i++) {
								randValueList.add(decAndRandValueList.get(i));
							}
							Row newRow = new Row(decValueList, randValueList, utility);
							newRewardTable.addRow(newRow);
						}
//						constraintTableWithRandomList.add(newRewardTable);
						rawRandomTableList.add(newRewardTable);
					}
				}
			}

			/** Place to test printing out */
			/** end of testing */
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	public void registerWithDF() {
		DFAgentDescription dfd = new DFAgentDescription();
		dfd.setName(getAID());
		for (int i = 0; i < neighborStrList.size(); i++) {
			ServiceDescription sd = new ServiceDescription();
			sd.setType(neighborStrList.get(i));
			sd.setName(agentID);
			dfd.addServices(sd);
		}
		try {
			DFService.register(this, dfd);
		} catch (FIPAException fe) {
			fe.printStackTrace();
		}
	}

	// get utility with parents, pseudoparents
	// then add its switching cost
	public double utilityWithParentAndPseudoAndUnary(int timeSteps) {
		double sumUtility = 0;

		for (int ts = 0; ts <= timeSteps; ts++) {
			List<Table> tableList = constraintTableAtEachTSMap.get(ts);
			for (Table constraintTable : tableList) {
				List<String> decVarList = constraintTable.getDecVarLabel();
				List<String> decValueList = new ArrayList<String>();

				// chi gui vá»›i constraint voi parent and pseudoparents
				boolean notInParentList = false;
				for (String var : decVarList) {
					if (var.equals(agentID))
						continue;
					if (parentAndPseudoStrList.contains(var) == false) {
						notInParentList = true;
						break;
					}
				}

				if (notInParentList)
					continue;

				for (String agentInList : decVarList) {
					if (agentInList.equals(agentID))
						decValueList.add(chosenValueAtEachTSMap.get(ts));
					else
						decValueList.add(agentViewEachTimeStepMap.get(agentInList).get(ts));
				}
				sumUtility += constraintTable.getUtilityGivenDecValueList(decValueList);
			}
		}
		return sumUtility;
	}
	
	public List<String> getSelfDomain() {
	  return decisionVariableDomainMap.get(agentID);
	}

	public double calculcatingSwitchingCost() {
		double sC = 0;
		if (chosenValueAtEachTSMap.size() == 1)
			return 0;
		for (int i = 0; i < chosenValueAtEachTSMap.size() - 1; i++) {
			sC += switchingCostFunction(chosenValueAtEachTSMap.get(i), chosenValueAtEachTSMap.get(i + 1));
		}
		return sC;
	}
	
	 /**
	  * Return switching cost in 0 or negative value
	  * @param oldValue
	  * @param newValue
	  * @return
	  */
	 public double switchingCostFunction(String oldValue, String newValue) {
	   boolean equal = oldValue.equals(newValue);
	   
	   double difference = Math.abs(Double.parseDouble(oldValue) - Double.parseDouble(newValue));
	   
	   switch (AgentPDDCOP.SWITCHING_TYPE) {
	     case CONSTANT:
	       return equal ? 0 : -switchingCost;
	     case LINEAR:
	       return equal ? 0 : -switchingCost * difference;
	     case QUADRATIC:
	       return equal ? 0 : -switchingCost * Math.pow(difference, 2);
	     case EXP_2:
	       return equal ? 0 : -switchingCost * Math.pow(2, difference);
	     case EXP_3:
	       return equal ? 0 : -switchingCost * Math.pow(3, difference);
	   }

	   return -Double.MAX_VALUE;
	 }	 
	 
  /**
   * Has taken into account the sum of discounted utility when FINITE and timeStep = horizon
   * @param decisionTableList
   * @param timeStep
   * @param discountFactor
   * @return
   */
  public List<Table> computeDiscountedDecisionTableList(List<Table> decisionTableList, int timeStep, double discountFactor) {
    List<Table> tableList = new ArrayList<>();
    for (Table decisionTable : decisionTableList) {
      tableList.add(computeDiscountedDecisionTable(decisionTable, timeStep, discountFactor));
    }
    return tableList;
  }
  
  public List<Table> computeDiscountedExpectedRandomTableList(List<Table> randomTableList, int timeStep, double discountFactor) {   
    List<Table> tableList = new ArrayList<>();
    for (Table randomTable : randomTableList) {
      tableList.add(computeDiscountedExpectedTable(randomTable, timeStep, discountFactor));
    }
    return tableList;
  }
  
  public Table computeDiscountedExpectedTable(Table randomTable, int timeStep, double discountFactor) {   
    if (dynamicType == DynamicType.FINITE_HORIZON && timeStep == horizon) {
      return computeLongtermExpectedTable(randomTable, timeStep, discountFactor);
    }
    
    List<String> decLabel = randomTable.getDecVarLabel();
    List<String> randLabel = randomTable.getRandVarLabel();
    Table discountedExpectedTable = new Table(decLabel);

    int randDomainSize = 1;
    for (String randVar : randLabel) {
      randDomainSize *= randomVariableDomainMap.get(randVar).size();
    }

    double expectedUtility = 0;
    // traverse rows
    for (int index = 0; index < randomTable.getRowCount(); index++) {
      Row row = randomTable.getRowList().get(index);
      List<String> decValueList = row.getValueList();
      List<String> randValueList = row.getRandomList();
      double initProb = 1;
      for (int idx = 0; idx < randLabel.size(); idx++) {
        String rand = randLabel.get(idx);
        initProb *= probabilityAtEachTimeStepMap.get(rand)[timeStep][randomVariableDomainMap.get(rand)
            .indexOf(randValueList.get(idx))];
      }
      expectedUtility += initProb * row.getUtility();

      // last turn
      if (index % randDomainSize == randDomainSize - 1) {
        Row newRow = null;
        newRow = new Row(decValueList, expectedUtility * Math.pow(discountFactor, timeStep));
        discountedExpectedTable.addRow(newRow);
        expectedUtility = 0;
      }
      // end of traversing row
    }
        
    return discountedExpectedTable;
  }
  
  public Table computeLongtermExpectedTable(Table randomTable, int timeStep, double discountFactor) {
    Table newlyCreatedTable;
    List<List<String>> processedDecValues = new ArrayList<List<String>>();

    List<String> decVarLabel = randomTable.getDecVarLabel();
    List<String> randVarLabel = randomTable.getRandVarLabel();
    List<List<String>> allTupleValue = getAllTupleValueOfGivenLabel(randVarLabel, false);
    newlyCreatedTable = new Table(decVarLabel, randVarLabel);

    int noOfEquations = 1;
    for (String randVar : randVarLabel) {
//      noOfEquations *= agent.getRandomVariableDomainMap().get(randVar).size();
      noOfEquations *= randomVariableDomainMap.get(randVar).size();
    }

    // traverse each row of tableWithRandom
    for (Row rowToBeTraversed : randomTable.getRowList()) {
      List<String> decValueList = rowToBeTraversed.getValueList();

      // check if decValueList contained in processedDecValues
      if (processedDecValues.contains(decValueList)) {
        continue;
      } // search for all values of random Variable
      else {
        processedDecValues.add(decValueList);
        /**
         * construct unknown equations, by add coefficients
         *
         * construct coefficients (1-delta*prob[0,0] - delta*prob[0,1] ... -
         * delta*prob[0,n] = v0 -delta*prob[1,0] + (1-delta*prob[1,1] ...-
         * delta*prob[1,n] = v1
         *
         * -delta*prob[n,0] - delta*prob[n,1] ... + (1-delta*prob[n,n] = v_n
         **/
        double coefficients[][] = new double[noOfEquations][noOfEquations + 1];
        // select rowTuple => colTuple
        for (int row = 0; row < noOfEquations; row++) {
          List<String> rowTuple = allTupleValue.get(row);
          // get colTuple
          for (int column = 0; column < noOfEquations; column++) {
            List<String> colTuple = allTupleValue.get(column);
            double transProb = 1;
            for (int randIndex = 0; randIndex < randVarLabel.size(); randIndex++) {
              String randVar = randVarLabel.get(randIndex);
              transProb = transProb
                  * transitionFunctionMap.get(randVar).getProbByValue(rowTuple.get(randIndex), colTuple.get(randIndex));
            }

            if (row == column)
              coefficients[row][column] = 1 - discountFactor * transProb;
            else
              coefficients[row][column] = -discountFactor * transProb;

          }
          // set utility
          coefficients[row][noOfEquations] = Math.pow(discountFactor, timeStep) * randomTable.getUtilityFromTableGivenDecAndRand(decValueList, rowTuple);
        }

        // System.out.println(Arrays.deepToString(coefficients));
        List<Double> utilityList = gaussian(coefficients, noOfEquations);

        // create new row with a fix dec values, but different rand values
        int i = 0;
        for (List<String> randValueToBeAddedList : allTupleValue) {
          Row newRow = new Row(decValueList, randValueToBeAddedList, utilityList.get(i));
          i++;
          newlyCreatedTable.addRow(newRow);
        }
        // end if: decValueList not contained
      }
      // end while: traversing table
    }
    return newlyCreatedTable;
  }
  
  private List<Double> gaussian(double arr[][], int N) {
    List<Double> longtermUtilityList = new ArrayList<Double>();
    // take each line as pivot, except for the last line
    for (int pivotIndex = 0; pivotIndex < N - 1; pivotIndex++) {
      // go from the line below line pivotIndex, to the last line
      boolean isNotZeroRowFound = false;
      if (arr[pivotIndex][pivotIndex] == 0) {
        int notZeroRow;
        for (notZeroRow = pivotIndex + 1; notZeroRow < N; notZeroRow++) {
          if (arr[notZeroRow][pivotIndex] != 0) {
            isNotZeroRowFound = true;
            break;
          }
        }

        if (isNotZeroRowFound) {
          // swap row pivotIndex and row notZeroRow
          for (int columnToSwapIndex = 0; columnToSwapIndex < N + 1; columnToSwapIndex++) {
            double tempForSwap = arr[pivotIndex][columnToSwapIndex];
            arr[pivotIndex][columnToSwapIndex] = arr[notZeroRow][columnToSwapIndex];
            arr[notZeroRow][columnToSwapIndex] = tempForSwap;
          }
        } else {
          continue;
        }
      }

      for (int rowForGauss = pivotIndex + 1; rowForGauss < N; rowForGauss++) {
        double factor = arr[rowForGauss][pivotIndex] / arr[pivotIndex][pivotIndex];
        for (int columnForGauss = 0; columnForGauss < N + 1; columnForGauss++) {
          arr[rowForGauss][columnForGauss] = arr[rowForGauss][columnForGauss]
              - factor * arr[pivotIndex][columnForGauss];
        }
      }
    }

    for (int columnPivot = N - 1; columnPivot >= 1; columnPivot--) {
      for (int rowAbovePivot = columnPivot - 1; rowAbovePivot >= 0; rowAbovePivot--) {
        double fraction = arr[rowAbovePivot][columnPivot] / arr[columnPivot][columnPivot];
        for (int columnInTheRow = 0; columnInTheRow < N + 1; columnInTheRow++)
          arr[rowAbovePivot][columnInTheRow] = arr[rowAbovePivot][columnInTheRow]
              - fraction * arr[columnPivot][columnInTheRow];
      }
    }

    for (int i = 0; i < N; i++) {
      longtermUtilityList.add(arr[i][N] / arr[i][i]);
    }

    return longtermUtilityList;
  }
  
  /**
   * Compute discounted or sum of discounted
   * @param decisionTable
   * @param timeStep
   * @param discountFactor
   * @return
   */
  public Table computeDiscountedDecisionTable(Table decisionTable, int timeStep, double discountFactor) {
    Table discountedTable = new Table(decisionTable.getDecVarLabel());
    for (Row decisionTableRow : decisionTable.getRowList()) {
      List<String> valueList = decisionTableRow.getValueList();
      double utility = decisionTableRow.getUtility();
      if (dynamicType == DynamicType.FINITE_HORIZON && timeStep == horizon) {
        discountedTable.addRow(new Row(valueList, utility * Math.pow(discountFactor, timeStep) / (1 - discountFactor)));
      }
      else {
        discountedTable.addRow(new Row(valueList, utility * Math.pow(discountFactor, timeStep)));
      }
    }
    return discountedTable;
 }

	public String getAgentID() {
		return agentID;
	}

	public boolean isRoot() {
		return isRoot;
	}

	public boolean isLeaf() {
		return isLeaf;
	}

	public void setLeaf(boolean isLeaf) {
		this.isLeaf = isLeaf;
	}

	public List<AID> getNeighborAIDList() {
		return neighborAIDList;
	}

	public void setNeighborAIDList(List<AID> neighborAIDList) {
		this.neighborAIDList = neighborAIDList;
	}

	public List<String> getNeighborStrList() {
		return neighborStrList;
	}

	public void setNeighborStrList(List<String> neighborStrList) {
		this.neighborStrList = neighborStrList;
	}

	public Map<AID, Integer> getConstraintInfoMap() {
		return constraintInfoMap;
	}

	public void setConstraintInfoMap(HashMap<AID, Integer> constraintInfoMap) {
		this.constraintInfoMap = constraintInfoMap;
	}

	public boolean isNotVisited() {
		return notVisited;
	}

	public void setNotVisited(boolean notVisited) {
		this.notVisited = notVisited;
	}

	public List<AID> getChildrenAIDList() {
		return childrenAIDList;
	}

	public void setChildrenAIDList(List<AID> childrenAIDList) {
		this.childrenAIDList = childrenAIDList;
	}

	public AID getParentAID() {
		return parentAID;
	}

	public void setParentAID(AID parentAID) {
		this.parentAID = parentAID;
	}

	public List<String> getParentAndPseudoStrList() {
		return parentAndPseudoStrList;
	}

	public void setParentAndPseudoStrList(List<String> parentAndPseudoStrList) {
		this.parentAndPseudoStrList = parentAndPseudoStrList;
	}

	public List<AID> getPseudoChildrenAIDList() {
		return pseudoChildrenAIDList;
	}

	public void setPseudoChildrenAIDList(List<AID> pseudoChildrenAIDList) {
		this.pseudoChildrenAIDList = pseudoChildrenAIDList;
	}

	public List<AID> getPseudoParentAIDList() {
		return pseudoParentAIDList;
	}

	public void setPseudoParentAIDList(List<AID> pseudoParentAIDList) {
		this.pseudoParentAIDList = pseudoParentAIDList;
	}

	public ThreadMXBean getBean() {
		return bean;
	}

	public void setBean(ThreadMXBean bean) {
		this.bean = bean;
	}

	public long getCurrentStartTime() {
		return currentStartTime;
	}

	public void setCurrentStartTime(long currentStartTime) {
		this.currentStartTime = currentStartTime;
	}

	public HashMap<String, List<String>> getDecisionVariableDomainMap() {
		return decisionVariableDomainMap;
	}

	public void setDecisionVariableDomainMap(HashMap<String, List<String>> decisionVariableDomainMap) {
		this.decisionVariableDomainMap = decisionVariableDomainMap;
	}

	public String getChosenValueAtEachTimeStep(int timeStep) {
		return chosenValueAtEachTSMap.get(timeStep);
	}

	public void setChosenValueAtEachTimeStep(int timeStep, String chosenValue) {
	  this.chosenValueAtEachTSMap.put(timeStep, chosenValue);
	}
	
	public Map<Integer, String> getChosenValueAtEachTSMap() {
	  return this.chosenValueAtEachTSMap;
	}
	
	public void setValueAtTimeStep(int timeStep, String value) {
	  this.chosenValueAtEachTSMap.put(timeStep, value);
	}

	public long getSimulatedTime() {
		return simulatedTime;
	}

	public void setSimulatedTime(long simulatedTime) {
		this.simulatedTime = simulatedTime;
	}

	public void addupSimulatedTime(long time) {
		this.simulatedTime += time;
	}

	public HashMap<Integer, List<Table>> getConstraintTableAtEachTSMap() {
		return constraintTableAtEachTSMap;
	}

	public void setConstraintTableAtEachTSMap(HashMap<Integer, List<Table>> constraintTableAtEachTSMap) {
		this.constraintTableAtEachTSMap = constraintTableAtEachTSMap;
	}

	public Table getAgentViewTable() {
		return agentViewTable;
	}

	public void setAgentViewTable(Table agentViewTable) {
		this.agentViewTable = agentViewTable;
	}

	public List<Double> getCurrentGlobalUtilityList() {
		return currentGlobalUtilityList;
	}

	public void setCurrentGlobalUtilityList(List<Double> currentGlobalUtilityList) {
		this.currentGlobalUtilityList = currentGlobalUtilityList;
	}

	public double getCurrentLocalSearchSolutionQuality() {
		return currentLocalSearchSolutionQuality;
	}

	public void setCurrentLocalSearchSolutionQuality(double currentLocalSearchSolutionQuality) {
		this.currentLocalSearchSolutionQuality = currentLocalSearchSolutionQuality;
	}

	public double getSolutionQuality() {
		return solutionQuality;
	}

	public void setSolutionQuality(double solutionQuality) {
		this.solutionQuality = solutionQuality;
	}
	
	public void increaseSolutionQuality(double quality) {
	  this.solutionQuality += quality;
	}

	public static long getDelayMessageTime() {
		return delayMessageTime;
	}

	public static void setDelayMessageTime(long delayMessageTime) {
		AgentPDDCOP.delayMessageTime = delayMessageTime;
	}

	public Map<String, HashMap<Integer, String>> getAgentViewEachTimeStepMap() {
		return agentViewEachTimeStepMap;
	}

	public void setAgentViewEachTimeStepMap(HashMap<String, HashMap<Integer, String>> agentViewEachTimeStepMap) {
		this.agentViewEachTimeStepMap = agentViewEachTimeStepMap;
	}

	public int getLocalSearchIteration() {
		return localSearchIteration;
	}

	public void setLsIteration(int lsIteration) {
		this.localSearchIteration = lsIteration;
	}

	public void incrementLocalSearchIteration() {
		this.localSearchIteration++;
	}

	public List<String> getBestImproveValueList() {
		return bestImproveValueList;
	}

	public void setBestImproveValueListJESP(List<String> bestImproveValueList) {
		this.bestImproveValueList = bestImproveValueList;
	}

	public double getBestLocalSearchQuality() {
		return bestLocalSearchQuality;
	}

	public void setBestLocalSearchQuality(double bestLocalSearchQuality) {
		this.bestLocalSearchQuality = bestLocalSearchQuality;
	}

	public boolean isStop() {
		return stop;
	}

	public void setStop(boolean stop) {
		this.stop = stop;
	}

	public double getCurentLocalSearchQuality() {
		return curentLocalSearchQuality;
	}

	public void setCurentLocalSearchQuality(double curentLocalSearchQuality) {
		this.curentLocalSearchQuality = curentLocalSearchQuality;
	}

	public Map<String, String> getValuesToSendInVALUEPhase() {
		return valuesToSendInVALUEPhase;
	}

	public void setValuesToSendInVALUEPhase(HashMap<String, String> valuesToSendInVALUEPhase) {
		this.valuesToSendInVALUEPhase = valuesToSendInVALUEPhase;
	}

	public void addValuesToSendInValuePhase(String agent, String value) {
		this.valuesToSendInVALUEPhase.put(agent, value);
	}

	public Map<Integer, String> getPickedRandomMap() {
		return pickedRandomMap;
	}

	public void setPickedRandomMap(HashMap<Integer, String> pickedRandomMap) {
		this.pickedRandomMap = pickedRandomMap;
	}

	public void addPickedRandomMap(Integer timeStep, String pickedRandomValue) {
		this.pickedRandomMap.put(timeStep, pickedRandomValue);
	}

	public String getPickedRandomAt(Integer timeStep) {
		return this.pickedRandomMap.get(timeStep);
	}

	public long getCurrentUTILstartTime() {
		return currentUTILstartTime;
	}

	public void setCurrentUTILstartTime(long currentUTILstartTime) {
		this.currentUTILstartTime = currentUTILstartTime;
	}

	public String getLastLine() {
		return lastLine;
	}

	public void setLastLine(String lastLine) {
		this.lastLine = lastLine;
	}

	public double[] toArray(List<Double> arrayList) {
		int arrSize = arrayList.size();
		double[] convertedArray = new double[arrSize];
		for (int i = 0; i < arrSize; i++) {
			convertedArray[i] = arrayList.get(i);
		}
		return convertedArray;
	}

	// each row is a timeStep from 0 to finalTimeStep
	// each column is a value from domain
	public String simulateRandom(int currentTimeStep) {
		// randomVar is the same as decisionVar string
		String randomVar = agentID;
		double distribution[] = null;
		// if currentTimeStep = 0 -> get from initial distribution
		if (currentTimeStep == 0) {
			distribution = toArray(initProabilityMap.get(randomVar));
		}
		// get distribution from transition function, from the previous random
		// values
		else {
			String previousRandValue = getPickedRandomAt(currentTimeStep - 1);
			distribution = toArray(transitionFunctionMap.get(randomVar).getTransitionOf(previousRandValue));
		}

		double rand = Math.random();
		double accumualatedProbability = 0;
		for (int i = 0; i < distribution.length; i++) {
			accumualatedProbability += distribution[i];
			if (rand < accumualatedProbability)
				return randomVariableDomainMap.get(randomVar).get(i);
		}
		return null;
	}

	public void addReactRandomTableToList(int timeStep) {
		// traverse to each random table
		for (Table randTable : rawRandomTableList) {
			List<String> decLabel = randTable.getDecVarLabel();
			// at current time step, create a new table, simulate the random,
			// and add the corresponding random values

			Table newTable = new Table(decLabel);
			String simulatedRandomValues = simulateRandom(timeStep);
			addPickedRandomMap(timeStep, simulatedRandomValues);

			for (Row row : randTable.getRowList()) {
				if (row.getRandomList().get(0).equals(simulatedRandomValues))
					newTable.addRow(new Row(row.getValueList(), row.getUtility()));
			}
			constraintTableAtEachTSMap.get(timeStep).add(newTable);
		}
	}

	public static double[] multiply(double[] vector, TransitionFunction transFunc) {
		int size = vector.length;
		if (size != transFunc.getSize()) {
			System.err.println("Not a square matrix");
			return null;
		}

		double resultVector[] = new double[size];
		for (int col = 0; col < size; col++) {
			for (int k = 0; k < size; k++) {
				resultVector[col] += vector[k] * transFunc.getProbByIndex(k, col);
			}
		}

		return resultVector;
	}

  public String getOutputFileName() {
    return outputFileName;
  }

  public void setOutputFileName(String outputFileName) {
    this.outputFileName = outputFileName;
  }
  
  public boolean isAlgorithmIn(DcopAlgorithm[] dcopAlgorithmArray) {
    for (DcopAlgorithm algorithmInArray : dcopAlgorithmArray) { 
      if (algorithm == algorithmInArray) {
        return true;
      }
    }
    
    return false;
  }
  
  public boolean isDynamic(DynamicType type) {
    return dynamicType == type;
  }
  
  public DynamicType getDynamicType() {
    return dynamicType;
  }

  public int getHybridTS() {
    return hybridTS;
  }

  public List<Double> getBestUtilityList() {
    return bestUtilityList;
  }

  public void setBestUtilityList(List<Double> bestUtilityList) {
    this.bestUtilityList = bestUtilityList;
  }

  public int getHorizon() {
    return horizon;
  }

  public DcopAlgorithm getAlgorithm() {
    return algorithm;
  }

  public double getSwitchingCost() {
    return switchingCost;
  }

  public int getInstanceID() {
    return instanceID;
  }

  public void setInstanceID(int instanceID) {
    this.instanceID = instanceID;
  }
  
  public boolean isRunningAlgorithm(DcopAlgorithm algorithm) {
    return this.algorithm == algorithm;
  }

  public String getInputFileName() {
    return inputFileName;
  }

  public List<Table> getRawDecisionTableList() {
    return rawDecisionTableList;
  }

  public List<Table> getRawRandomTableList() {
    return rawRandomTableList;
  }

  public double getDiscountFactor() {
    return discountFactor;
  }

  public HashMap<String, List<String>> getRandomVariableDomainMap() {
    return randomVariableDomainMap;
  }

  public HashMap<String, double[][]> getProbabilityAtEachTimeStepMap() {
    return probabilityAtEachTimeStepMap;
  }

  public List<Table> getDpopDecisionTableList() {
    return dpopDecisionTableList;
  }

  public List<Table> getDpopRandomTableList() {
    return dpopRandomTableList;
  }
  
  public Map<String, TransitionFunction> getTransitionFunctionMap() {
    return transitionFunctionMap;
  }

  /**
   * @return the agentCount
   */
  public int getAgentCount() {
    return agentCount;
  }
  
  public void updateSolutionQuality(double utility) {
    solutionQuality += utility;
  }

  public void storeDpopSolution(String value, int timeStep) {
    // Store solution at each time step
    if (algorithm == DcopAlgorithm.C_DPOP) {
      // Set single value at horizon h 
      if (dynamicType == DynamicType.INFINITE_HORIZON && timeStep == horizon) {
        chosenValueAtEachTSMap.put(horizon, value);
      }
      // Set a sequence of values
      else {
        String[] values = value.split(",");
        for (int i = 0; i < values.length; i++) {
          chosenValueAtEachTSMap.put(i, values[i]);  
        }
      }
    }
    else if (isAlgorithmIn(new DcopAlgorithm[]{
        DcopAlgorithm.FORWARD, DcopAlgorithm.BACKWARD, DcopAlgorithm.LS_SDPOP})) { 
      chosenValueAtEachTSMap.put(timeStep, value);
    }    
  }
  
  /**
   * @return the bestImproveUtilityList
   */
  public List<Double> getBestImproveUtilityList() {
    return bestImproveUtilityList;
  }

  /**
   * Set currentStartTime at the time the function is called
   */
  public void startSimulatedTiming() {
    currentStartTime = getBean().getCurrentThreadUserTime();
  }

  /**
   * Update the simulated runtime += currentTime - currentStartTime
   */
  public void stopStimulatedTiming() {
    simulatedTime += bean.getCurrentThreadUserTime() - currentStartTime;    
  }
}
